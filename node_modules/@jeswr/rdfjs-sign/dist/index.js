"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportPrivateKey = exports.exportKey = exports.importKey = exports.importPrivateKey = exports.generateKeyPair = exports.verifyQuads = exports.signQuads = exports.hashDataGraph = exports.signParams = exports.keyParams = void 0;
const rdfjs_c14n_1 = require("rdfjs-c14n");
const crypto_1 = require("crypto");
exports.keyParams = {
    name: 'ECDSA',
    namedCurve: 'P-384',
};
exports.signParams = {
    name: exports.keyParams.name,
    hash: 'SHA-512',
};
function hashDataGraph(input) {
    return __awaiter(this, void 0, void 0, function* () {
        const rdfc10 = new rdfjs_c14n_1.RDFC10();
        const normalized = (yield rdfc10.c14n(input)).canonicalized_dataset;
        const hash = yield rdfc10.hash(normalized);
        return new TextEncoder().encode(hash);
    });
}
exports.hashDataGraph = hashDataGraph;
function signDataGraph(input, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return crypto_1.subtle.sign(exports.signParams, privateKey, yield hashDataGraph(input));
    });
}
function signQuads(content, privateKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return Buffer.from(yield signDataGraph(content, privateKey)).toString('base64');
    });
}
exports.signQuads = signQuads;
function verifyQuads(input, signature, publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        return crypto_1.subtle.verify(exports.signParams, publicKey, Buffer.from(signature, 'base64'), yield hashDataGraph(input));
    });
}
exports.verifyQuads = verifyQuads;
function generateKeyPair() {
    return crypto_1.subtle.generateKey(exports.keyParams, true, ['sign', 'verify']);
}
exports.generateKeyPair = generateKeyPair;
function importPrivateKey(key) {
    return crypto_1.subtle.importKey('jwk', key, exports.keyParams, true, ['sign']);
}
exports.importPrivateKey = importPrivateKey;
function importKey(key) {
    return crypto_1.subtle.importKey('raw', Buffer.from(key, 'base64'), exports.keyParams, true, ['verify']);
}
exports.importKey = importKey;
function exportKey(key) {
    return __awaiter(this, void 0, void 0, function* () {
        return Buffer.from(yield crypto_1.subtle.exportKey('raw', key)).toString('base64');
    });
}
exports.exportKey = exportKey;
function exportPrivateKey(key) {
    return __awaiter(this, void 0, void 0, function* () {
        return crypto_1.subtle.exportKey('jwk', key);
    });
}
exports.exportPrivateKey = exportPrivateKey;
