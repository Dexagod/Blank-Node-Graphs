{"version":3,"file":"ActorDereferenceParse.js","sourceRoot":"","sources":["ActorDereferenceParse.ts"],"names":[],"mappings":";;;AAIA,qDAA8C;AAE9C,iEAA2E;AAE3E;;;;;;;GAOG;AACH,SAAgB,yBAAyB,CAAC,IAAY,EAAE,aAAsC;IAC5F,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;IACvC,gDAAgD;IAChD,OAAO,CAAC,QAAQ,IAAI,CAAC,IAAI,aAAa,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AAC5E,CAAC;AAJD,8DAIC;AAiBD;;;;;;;;GAQG;AACH,MAAsB,qBAIpB,SAAQ,2CAAgG;IAMxG,YAAmB,IAAyC;QAC1D,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAA0B;QAC1C,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACO,6BAA6B,CACrC,MAAkC,EAClC,IAAO;QAEP,oGAAoG;QACpG,IAAI,CAAC,IAAA,kCAAW,EAAC,MAAM,CAAC,OAAO,CAAC,EAAE;YAChC,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE;gBACvB,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC1E,yCAAyC;gBACzC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClB,CAAC,CAAC,CAAC;YACH,IAAI,GAAqB,IAAI,CAAC,IAAI,CAAC,IAAI,6BAAW,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;SAC3E;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAIM,KAAK,CAAC,GAAG,CAAC,MAAkC;QACjD,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC;QAC3B,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC;YACzD,GAAG,MAAM;YACT,UAAU,EAAE,KAAK,IAAG,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,uBAAuB,EAAE,OAAO,CAAC,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,UAAU;SAChH,CAAC,CAAC;QAEH,IAAI,MAA+B,CAAC;QACpC,IAAI;YACF,MAAM,GAAG,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC;gBACzC,OAAO;gBACP,MAAM,EAAE,EAAE,OAAO,EAAE,GAAG,WAAW,EAAE,QAAQ,EAAE,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,EAAE;gBAClF,eAAe,EAAE,WAAW,CAAC,SAAS;oBACpC,yBAAyB,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,CAAC,aAAa,CAAC;oBAC9D,MAAM,CAAC,SAAS;aACnB,CAAC,CAAC,CAAC,MAAM,CAAC;YACX,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,6BAA6B,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;SACvE;QAAC,OAAO,KAAc,EAAE;YACvB,2CAA2C;YAC3C,MAAM,WAAW,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,CAAC;YACjC,MAAM,GAAG,MAAM,IAAI,CAAC,uBAAuB,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC,CAAC;SAChE;QAED,4CAA4C;QAC5C,OAAO,EAAE,GAAG,WAAW,EAAE,GAAG,MAAM,EAAE,CAAC;IACvC,CAAC;CACF;AApED,sDAoEC","sourcesContent":["import type { MediateMediaTyped, MediateMediaTypes } from '@comunica/actor-abstract-mediatyped';\nimport type { IActionParse, IActorParseOutput, IParseMetadata } from '@comunica/actor-abstract-parse';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport type { Readable } from 'readable-stream';\nimport { PassThrough } from 'readable-stream';\nimport type { IActionDereference, IActorDereferenceOutput, MediatorDereference } from './ActorDereference';\nimport { ActorDereferenceBase, isHardError } from './ActorDereferenceBase';\n\n/**\n * Get the media type based on the extension of the given path,\n * which can be an URL or file path.\n * @param {string} path A path.\n * @param {Record<string, string>} mediaMappings A collection of mappings,\n * mapping file extensions to their corresponding media type.\n * @return {string} A media type or the empty string.\n */\nexport function getMediaTypeFromExtension(path: string, mediaMappings?: Record<string, string>): string {\n  const dotIndex = path.lastIndexOf('.');\n  // Get extension after last dot and map to media\n  return (dotIndex >= 0 && mediaMappings?.[path.slice(dotIndex + 1)]) || '';\n}\n\nexport interface IActorDereferenceParseArgs<\n  S,\n  K extends IParseMetadata = IParseMetadata,\n  M extends IParseMetadata = IParseMetadata\n> extends IActorArgs<IActionDereferenceParse<K>, IActorTest, IActorDereferenceParseOutput<S, M>> {\n  mediatorDereference: MediatorDereference;\n  mediatorParse: MediateMediaTyped<IActionParse<K>, IActorTest, IActorParseOutput<S, M>>;\n  mediatorParseMediatypes: MediateMediaTypes;\n  /**\n   * A collection of mappings, mapping file extensions to their corresponding media type.\n   * @range {json}\n   */\n  mediaMappings: Record<string, string>;\n}\n\n/**\n * An abstract actor that handles dereference and parse actions.\n *\n * Actor types:\n * Input:  IActionDereferenceParse:      A URL.\n * Test:   <none>\n * Output: IActorDereferenceParseOutput: A data stream of type output by the Parser.\n *\n */\nexport abstract class ActorDereferenceParse<\n  S,\n  K extends IParseMetadata = IParseMetadata,\n  M extends IParseMetadata = IParseMetadata\n> extends ActorDereferenceBase<IActionDereferenceParse<K>, IActorTest, IActorDereferenceParseOutput<S, M>> {\n  public readonly mediatorDereference: MediatorDereference;\n  public readonly mediatorParse: MediateMediaTyped<IActionParse<K>, IActorTest, IActorParseOutput<S, M>>;\n  public readonly mediatorParseMediatypes: MediateMediaTypes;\n  public readonly mediaMappings: Record<string, string>;\n\n  public constructor(args: IActorDereferenceParseArgs<S, K, M>) {\n    super(args);\n  }\n\n  public async test(action: IActionDereference): Promise<IActorTest> {\n    return true;\n  }\n\n  /**\n   * If hard errors are disabled, modify the given stream so that errors are delegated to the logger.\n   * @param {IActionDereferenceParse} action A dereference action.\n   * @param {Readable} data A data stream.\n   * @return {Readable} The resulting data stream.\n   */\n  protected handleDereferenceStreamErrors<L extends IParseMetadata, T extends Readable>(\n    action: IActionDereferenceParse<L>,\n    data: T,\n  ): T {\n    // If we don't emit hard errors, make parsing error events log instead, and silence them downstream.\n    if (!isHardError(action.context)) {\n      data.on('error', error => {\n        this.logError(action.context, error.message, () => ({ url: action.url }));\n        // Make sure the errored stream is ended.\n        data.push(null);\n      });\n      data = <PassThrough & T> data.pipe(new PassThrough({ objectMode: true }));\n    }\n    return data;\n  }\n\n  public abstract getMetadata(dereference: IActorDereferenceOutput): Promise<K | undefined>;\n\n  public async run(action: IActionDereferenceParse<K>): Promise<IActorDereferenceParseOutput<S, M>> {\n    const { context } = action;\n    const dereference = await this.mediatorDereference.mediate({\n      ...action,\n      mediaTypes: async() => (await this.mediatorParseMediatypes?.mediate({ context, mediaTypes: true }))?.mediaTypes,\n    });\n\n    let result: IActorParseOutput<S, M>;\n    try {\n      result = (await this.mediatorParse.mediate({\n        context,\n        handle: { context, ...dereference, metadata: await this.getMetadata(dereference) },\n        handleMediaType: dereference.mediaType ||\n          getMediaTypeFromExtension(dereference.url, this.mediaMappings) ||\n          action.mediaType,\n      })).handle;\n      result.data = this.handleDereferenceStreamErrors(action, result.data);\n    } catch (error: unknown) {\n      // Close the body, to avoid process to hang\n      await dereference.data.close?.();\n      result = await this.dereferenceErrorHandler(action, error, {});\n    }\n\n    // Return the parsed stream and any metadata\n    return { ...dereference, ...result };\n  }\n}\n\nexport interface IActionDereferenceParse<T extends IParseMetadata = IParseMetadata> extends IActionDereference {\n  /**\n   * The mediatype of the source (if it can't be inferred from the source)\n   */\n  mediaType?: string;\n  /**\n   * Metadata to be given to the parser\n   */\n  metadata?: T;\n}\n\nexport type IActorDereferenceParseOutput<T, K extends IParseMetadata = IParseMetadata>\n  = Omit<IActorDereferenceOutput, 'data'> & IActorParseOutput<T, K>;\n"]}